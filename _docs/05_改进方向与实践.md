# Open-AutoGLM æ”¹è¿›æ–¹å‘ä¸å®è·µ

æœ¬æ–‡æ¡£åˆ†æé¡¹ç›®çš„å±€é™æ€§ï¼Œå¹¶æä¾›å…·ä½“çš„æ”¹è¿›æ–¹å‘å’Œå®è·µæŒ‡å—ã€‚

---

## ğŸ” å½“å‰ç³»ç»Ÿçš„å±€é™æ€§

### 1. ä¾èµ–çº¯è§†è§‰ç†è§£

**ç°çŠ¶**:
- ä»…é€šè¿‡å±å¹•æˆªå›¾ç†è§£ç•Œé¢
- æ— æ³•è·å– UI å…ƒç´ çš„ç²¾ç¡®ä¿¡æ¯

**é—®é¢˜**:
- å°æŒ‰é’®ã€æ–‡å­—è¯†åˆ«ä¸å‡†ç¡®
- å¤æ‚ç•Œé¢å®¹æ˜“æ··æ·†
- æ— æ³•åŒºåˆ†è§†è§‰ç›¸ä¼¼çš„å…ƒç´ 

**å½±å“**:
- ç‚¹å‡»å‡†ç¡®ç‡å—é™
- æŸäº›ç²¾ç»†æ“ä½œéš¾ä»¥å®Œæˆ

---

### 2. å“åº”å»¶è¿Ÿè¾ƒå¤§

**ç°çŠ¶**:
- æ¯æ­¥éœ€è¦: æˆªå›¾ (0.5s) + æ¨¡å‹æ¨ç† (1-3s) + æ‰§è¡Œ (0.5-1s)
- å•æ­¥æ€»è€—æ—¶: 2-5 ç§’

**é—®é¢˜**:
- ç”¨æˆ·ç­‰å¾…æ—¶é—´é•¿
- æ— æ³•å¤„ç†å®æ—¶æ€§è¦æ±‚é«˜çš„ä»»åŠ¡

**å½±å“**:
- ç”¨æˆ·ä½“éªŒä¸ä½³
- ä¸é€‚åˆæ¸¸æˆã€è§†é¢‘ç­‰åœºæ™¯

---

### 3. Token æ¶ˆè€—å·¨å¤§

**ç°çŠ¶**:
- æ¯å¼ å›¾åƒ: ~1000-2000 tokens
- 10 æ­¥ä»»åŠ¡: ~15,000-25,000 tokens

**é—®é¢˜**:
- æ¨ç†æˆæœ¬é«˜
- é™åˆ¶äº†ä»»åŠ¡çš„å¤æ‚åº¦

**å½±å“**:
- è¿è¡Œæˆæœ¬é«˜
- é•¿ä»»åŠ¡å®¹æ˜“è¶…å‡ºä¸Šä¸‹æ–‡é™åˆ¶

---

### 4. é”™è¯¯ç´¯ç§¯é—®é¢˜

**ç°çŠ¶**:
- ä¸€æ­¥é”™è¯¯å¯èƒ½å¯¼è‡´åç»­å…¨é”™
- ç¼ºå°‘ä¸»åŠ¨çº é”™æœºåˆ¶

**é—®é¢˜**:
- ç‚¹å‡»ä½ç½®åå·® â†’ è¿›å…¥é”™è¯¯é¡µé¢
- ç†è§£é”™è¯¯ â†’ æ‰§è¡Œé”™è¯¯åŠ¨ä½œ

**å½±å“**:
- ä»»åŠ¡å®Œæˆç‡å—å½±å“
- å¤æ‚ä»»åŠ¡å®¹æ˜“å¤±è´¥

---

### 5. ç¼ºå°‘å­¦ä¹ èƒ½åŠ›

**ç°çŠ¶**:
- æ¯æ¬¡ä»»åŠ¡éƒ½æ˜¯ç‹¬ç«‹çš„
- ä¸ä»å†å²ç»éªŒä¸­å­¦ä¹ 

**é—®é¢˜**:
- åŒæ ·çš„é”™è¯¯å¯èƒ½é‡å¤çŠ¯
- æ— æ³•ç§¯ç´¯ä¼˜åŒ–ç­–ç•¥

**å½±å“**:
- ç³»ç»Ÿä¸ä¼šéšä½¿ç”¨è€Œæ”¹è¿›

---

### 6. å®‰å…¨æ€§é—®é¢˜

**ç°çŠ¶**:
- ä½¿ç”¨ `eval()` è§£æåŠ¨ä½œ
- æ— è¾“å…¥éªŒè¯

**é—®é¢˜**:
- ä»£ç æ³¨å…¥é£é™©
- æ¶æ„æŒ‡ä»¤å¯èƒ½è¢«æ‰§è¡Œ

**å½±å“**:
- ä¸é€‚åˆå¼€æ”¾ç¯å¢ƒéƒ¨ç½²

---

## ğŸš€ æ”¹è¿›æ–¹å‘

æ ¹æ®éš¾åº¦å’Œä»·å€¼ï¼Œåˆ†ä¸ºåˆçº§ã€ä¸­çº§ã€é«˜çº§ä¸‰ä¸ªå±‚æ¬¡ã€‚

---

## ğŸŒŸ åˆçº§æ”¹è¿›ï¼ˆ1-3å¤©ï¼‰

é€‚åˆåˆå­¦è€…ï¼Œå¯å¿«é€Ÿè§æ•ˆã€‚

### 1. æ·»åŠ æ–°çš„åŠ¨ä½œç±»å‹

**ç›®æ ‡**: æ”¯æŒæ›´å¤šæ“ä½œï¼Œå¦‚åŒæŒ‡ç¼©æ”¾ã€æ‹–æ‹½

**å®ç°æ­¥éª¤**:

1. **åœ¨ `prompts.py` ä¸­æ·»åŠ åŠ¨ä½œå®šä¹‰**:
```python
SYSTEM_PROMPT += """
- do(action="Pinch", center=[x,y], scale=1.5)  
    Pinchæ˜¯åŒæŒ‡ç¼©æ”¾æ“ä½œï¼Œcenteræ˜¯ç¼©æ”¾ä¸­å¿ƒï¼Œscale>1ä¸ºæ”¾å¤§ï¼Œscale<1ä¸ºç¼©å°ã€‚
"""
```

2. **åœ¨ `handler.py` ä¸­å®ç°å¤„ç†æ–¹æ³•**:
```python
def _handle_pinch(self, action: dict, width: int, height: int):
    """å¤„ç†ç¼©æ”¾åŠ¨ä½œ"""
    center = action.get("center")
    scale = action.get("scale", 1.5)
    
    x, y = self._convert_relative_to_absolute(center, width, height)
    
    # è®¡ç®—ä¸¤ä¸ªæ‰‹æŒ‡çš„èµ·å§‹å’Œç»“æŸä½ç½®
    offset = 100  # åˆå§‹è·ç¦»
    end_offset = int(offset * scale)
    
    # æ¨¡æ‹ŸåŒæŒ‡ç¼©æ”¾ (ä¸¤ä¸ªåŒæ—¶æ»‘åŠ¨)
    # æ‰‹æŒ‡1: ä»ä¸Šæ–¹å‘ä¸­å¿ƒ/å¤–ä¾§ç§»åŠ¨
    # æ‰‹æŒ‡2: ä»ä¸‹æ–¹å‘ä¸­å¿ƒ/å¤–ä¾§ç§»åŠ¨
    swipe(x, y - offset, x, y - end_offset, device_id=self.device_id)
    time.sleep(0.1)
    swipe(x, y + offset, x, y + end_offset, device_id=self.device_id)
    
    return ActionResult(True, False)
```

3. **åœ¨ `_get_handler()` ä¸­æ³¨å†Œ**:
```python
def _get_handler(self, action_name: str):
    handlers = {
        # ... åŸæœ‰åŠ¨ä½œ ...
        "Pinch": self._handle_pinch,  # æ–°å¢
    }
    return handlers.get(action_name)
```

4. **æµ‹è¯•**:
```python
agent = PhoneAgent()
result = agent.run("æ‰“å¼€åœ°å›¾å¹¶æ”¾å¤§ä¸¤å€")
```

---

### 2. å¢åŠ æ›´å¤šåº”ç”¨æ”¯æŒ

**ç›®æ ‡**: æ”¯æŒæ›´å¤š Android åº”ç”¨

**å®ç°æ­¥éª¤**:

1. **æ‰¾åˆ°åº”ç”¨çš„åŒ…å**:
```bash
# æ–¹æ³•1: å¯åŠ¨åº”ç”¨åæŸ¥è¯¢
adb shell dumpsys window | grep mCurrentFocus

# æ–¹æ³•2: åˆ—å‡ºæ‰€æœ‰å·²å®‰è£…åº”ç”¨
adb shell pm list packages

# æ–¹æ³•3: æŸ¥çœ‹åº”ç”¨è¯¦æƒ…
adb shell pm dump <package-name> | grep -i "package"
```

2. **æ·»åŠ åˆ° `apps.py`**:
```python
APP_PACKAGES: dict[str, str] = {
    # ... åŸæœ‰åº”ç”¨ ...
    
    # æ–°å¢åº”ç”¨
    "Twitter": "com.twitter.android",
    "Instagram": "com.instagram.android",
    "Telegram": "org.telegram.messenger",
}
```

3. **æµ‹è¯•**:
```python
agent.run("æ‰“å¼€Twitteræœç´¢Python")
```

---

### 3. ä¼˜åŒ–æ—¥å¿—è¾“å‡º

**ç›®æ ‡**: æ›´å‹å¥½çš„æ—¥å¿—æ ¼å¼ï¼Œæ”¯æŒæ—¥å¿—ä¿å­˜

**å®ç°**:

```python
# agent.py
import logging
from datetime import datetime

class PhoneAgent:
    def __init__(self, ...):
        # ... åŸæœ‰ä»£ç  ...
        
        # è®¾ç½®æ—¥å¿—
        if self.agent_config.verbose:
            self._setup_logger()
    
    def _setup_logger(self):
        """é…ç½®æ—¥å¿—ç³»ç»Ÿ"""
        log_dir = "logs"
        os.makedirs(log_dir, exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        log_file = f"{log_dir}/agent_{timestamp}.log"
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s [%(levelname)s] %(message)s',
            handlers=[
                logging.FileHandler(log_file, encoding='utf-8'),
                logging.StreamHandler()
            ]
        )
        
        self.logger = logging.getLogger(__name__)
    
    def _execute_step(self, ...):
        # ... åŸæœ‰ä»£ç  ...
        
        if self.agent_config.verbose:
            self.logger.info("=" * 50)
            self.logger.info(f"Step {self._step_count}")
            self.logger.info(f"Current App: {current_app}")
            self.logger.info(f"ğŸ’­ Thinking: {response.thinking}")
            self.logger.info(f"ğŸ¯ Action: {json.dumps(action, ensure_ascii=False)}")
            self.logger.info("=" * 50)
```

---

### 4. æ·»åŠ ä»»åŠ¡å†å²è®°å½•

**ç›®æ ‡**: è®°å½•æ¯ä¸ªä»»åŠ¡çš„æ‰§è¡Œè¿‡ç¨‹ï¼Œä¾¿äºåˆ†æ

**å®ç°**:

```python
# agent.py
import json
from datetime import datetime

@dataclass
class TaskRecord:
    """ä»»åŠ¡è®°å½•"""
    task: str
    start_time: str
    end_time: str
    steps: list[dict]
    result: str
    success: bool

class PhoneAgent:
    def __init__(self, ...):
        # ... åŸæœ‰ä»£ç  ...
        self._task_history: list[TaskRecord] = []
    
    def run(self, task: str) -> str:
        start_time = datetime.now().isoformat()
        steps = []
        
        # ... æ‰§è¡Œä»»åŠ¡ ...
        
        while self._step_count < self.agent_config.max_steps:
            result = self._execute_step(is_first=False)
            
            # è®°å½•æ¯ä¸€æ­¥
            steps.append({
                "step": self._step_count,
                "thinking": result.thinking,
                "action": result.action,
                "success": result.success
            })
            
            if result.finished:
                final_message = result.message or "Task completed"
                break
        
        # ä¿å­˜ä»»åŠ¡è®°å½•
        record = TaskRecord(
            task=task,
            start_time=start_time,
            end_time=datetime.now().isoformat(),
            steps=steps,
            result=final_message,
            success=result.finished and result.success
        )
        self._task_history.append(record)
        
        # ä¿å­˜åˆ°æ–‡ä»¶
        self._save_history()
        
        return final_message
    
    def _save_history(self):
        """ä¿å­˜ä»»åŠ¡å†å²åˆ° JSON"""
        with open("task_history.json", "w", encoding="utf-8") as f:
            json.dump(
                [asdict(record) for record in self._task_history],
                f, 
                ensure_ascii=False, 
                indent=2
            )
```

---

## âš™ï¸ ä¸­çº§æ”¹è¿›ï¼ˆ3-7å¤©ï¼‰

éœ€è¦ä¸€å®šå¼€å‘ç»éªŒã€‚

### 1. é›†æˆ UIAutomator (ç»“æ„åŒ– UI)

**ç›®æ ‡**: è·å– UI å…ƒç´ æ ‘ï¼Œæé«˜ç‚¹å‡»å‡†ç¡®ç‡

**åŸç†**:
- UIAutomator å¯ä»¥å¯¼å‡º UI å±‚çº§ç»“æ„
- æ¯ä¸ªå…ƒç´ æœ‰ IDã€classã€boundsã€text ç­‰å±æ€§

**å®ç°æ­¥éª¤**:

1. **å¯¼å‡º UI å±‚çº§**:
```python
# adb/ui_parser.py
import xml.etree.ElementTree as ET

def get_ui_hierarchy(device_id: str | None = None) -> dict:
    """è·å– UI å±‚çº§ç»“æ„"""
    adb_prefix = _get_adb_prefix(device_id)
    
    # å¯¼å‡º UI åˆ°è®¾å¤‡
    subprocess.run(
        adb_prefix + ["shell", "uiautomator", "dump", "/sdcard/ui.xml"],
        capture_output=True
    )
    
    # æ‹‰å–åˆ°æœ¬åœ°
    temp_path = f"/tmp/ui_{uuid.uuid4()}.xml"
    subprocess.run(
        adb_prefix + ["pull", "/sdcard/ui.xml", temp_path],
        capture_output=True
    )
    
    # è§£æ XML
    tree = ET.parse(temp_path)
    root = tree.getroot()
    
    # æå–å¯ç‚¹å‡»å…ƒç´ 
    clickable_elements = []
    for node in root.iter():
        if node.get("clickable") == "true":
            bounds = node.get("bounds")  # [x1,y1][x2,y2]
            text = node.get("text", "")
            content_desc = node.get("content-desc", "")
            
            # è§£æ bounds
            x1, y1, x2, y2 = parse_bounds(bounds)
            center_x = (x1 + x2) // 2
            center_y = (y1 + y2) // 2
            
            clickable_elements.append({
                "text": text,
                "description": content_desc,
                "center": [center_x, center_y],
                "bounds": [x1, y1, x2, y2]
            })
    
    os.remove(temp_path)
    return {"elements": clickable_elements}

def parse_bounds(bounds_str: str) -> tuple:
    """è§£æ bounds å­—ç¬¦ä¸² '[x1,y1][x2,y2]' """
    import re
    matches = re.findall(r'\[(\d+),(\d+)\]', bounds_str)
    x1, y1 = int(matches[0][0]), int(matches[0][1])
    x2, y2 = int(matches[1][0]), int(matches[1][1])
    return x1, y1, x2, y2
```

2. **å°† UI ä¿¡æ¯æ·»åŠ åˆ°æç¤ºè¯**:
```python
# agent.py - _execute_step()
from phone_agent.adb.ui_parser import get_ui_hierarchy

def _execute_step(self, ...):
    screenshot = get_screenshot(device_id)
    current_app = get_current_app(device_id)
    
    # æ–°å¢: è·å– UI å±‚çº§
    ui_hierarchy = get_ui_hierarchy(device_id)
    
    # æ„å»ºæ›´ä¸°å¯Œçš„å±å¹•ä¿¡æ¯
    screen_info = MessageBuilder.build_screen_info(
        current_app=current_app,
        clickable_elements=ui_hierarchy["elements"][:10]  # åªå–å‰10ä¸ª
    )
    
    # ... åç»­æµç¨‹ ...
```

3. **å¢å¼ºæç¤ºè¯**:
```python
SYSTEM_PROMPT += """
åœ¨å±å¹•ä¿¡æ¯ä¸­ï¼Œä½ ä¼šçœ‹åˆ°å¯ç‚¹å‡»å…ƒç´ åˆ—è¡¨ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
{
  "current_app": "å°çº¢ä¹¦",
  "clickable_elements": [
    {"text": "æœç´¢", "center": [540, 100]},
    {"text": "å‘å¸ƒ", "center": [960, 100]}
  ]
}

å¦‚æœèƒ½åŒ¹é…åˆ°å…ƒç´ æ–‡æœ¬ï¼Œä¼˜å…ˆä½¿ç”¨å…ƒç´ ä¸­å¿ƒåæ ‡è¿›è¡Œç‚¹å‡»ã€‚
"""
```

**ä¼˜åŠ¿**:
- âœ… æé«˜ç‚¹å‡»å‡†ç¡®ç‡
- âœ… å¯ä»¥é€šè¿‡æ–‡æœ¬å®šä½å…ƒç´ 
- âœ… å‡å°‘è§†è§‰è¯†åˆ«é”™è¯¯

---

### 2. å®ç°æ™ºèƒ½é‡è¯•æœºåˆ¶

**ç›®æ ‡**: åŠ¨ä½œå¤±è´¥æ—¶è‡ªåŠ¨é‡è¯•ï¼Œæé«˜æˆåŠŸç‡

**å®ç°**:

```python
# actions/handler.py
@dataclass
class ActionResult:
    success: bool
    should_finish: bool
    message: str | None = None
    should_retry: bool = False  # æ–°å¢: æ˜¯å¦åº”è¯¥é‡è¯•

class ActionHandler:
    def execute_with_retry(
        self, 
        action: dict, 
        screen_width: int, 
        screen_height: int,
        max_retries: int = 3
    ) -> ActionResult:
        """æ‰§è¡ŒåŠ¨ä½œï¼Œå¤±è´¥æ—¶è‡ªåŠ¨é‡è¯•"""
        for attempt in range(max_retries):
            result = self.execute(action, screen_width, screen_height)
            
            if result.success or not result.should_retry:
                return result
            
            if attempt < max_retries - 1:
                print(f"âš ï¸ åŠ¨ä½œå¤±è´¥ï¼Œ{attempt + 1}/{max_retries} æ¬¡é‡è¯•...")
                time.sleep(1.0)
        
        return result
    
    def _handle_tap(self, action: dict, width: int, height: int):
        """å¸¦éªŒè¯çš„ç‚¹å‡»"""
        element = action.get("element")
        x, y = self._convert_relative_to_absolute(element, width, height)
        
        # æˆªå›¾å‰çš„çŠ¶æ€
        before_screenshot = get_screenshot(self.device_id)
        
        # æ‰§è¡Œç‚¹å‡»
        tap(x, y, self.device_id)
        time.sleep(0.5)
        
        # æˆªå›¾åçš„çŠ¶æ€
        after_screenshot = get_screenshot(self.device_id)
        
        # æ£€æŸ¥å±å¹•æ˜¯å¦å˜åŒ–
        if self._screen_changed(before_screenshot, after_screenshot):
            return ActionResult(True, False)
        else:
            # å±å¹•æœªå˜åŒ– â†’ ç‚¹å‡»å¯èƒ½æ— æ•ˆï¼Œå»ºè®®é‡è¯•
            return ActionResult(
                False, False, 
                message="Screen not changed, may need retry",
                should_retry=True
            )
    
    def _screen_changed(self, before, after, threshold=0.1):
        """æ£€æŸ¥å±å¹•æ˜¯å¦å‘ç”Ÿæ˜¾è‘—å˜åŒ–"""
        # ç®€å•æ–¹æ³•: æ¯”è¾ƒ base64 å­—ç¬¦ä¸²
        return before.base64_data != after.base64_data
        
        # å¤æ‚æ–¹æ³•: è®¡ç®—å›¾åƒç›¸ä¼¼åº¦
        # from PIL import Image
        # import imagehash
        # hash1 = imagehash.average_hash(Image.open(BytesIO(base64.b64decode(before.base64_data))))
        # hash2 = imagehash.average_hash(Image.open(BytesIO(base64.b64decode(after.base64_data))))
        # return (hash1 - hash2) > threshold
```

**ä½¿ç”¨**:
```python
# agent.py
result = self.action_handler.execute_with_retry(
    action, screenshot.width, screenshot.height
)
```

---

### 3. æ·»åŠ  OCR æ–‡æœ¬è¯†åˆ«

**ç›®æ ‡**: è¯†åˆ«å±å¹•ä¸Šçš„æ–‡æœ¬ï¼Œè¾…åŠ©å®šä½

**å®ç°**:

```python
# adb/ocr.py
from paddleocr import PaddleOCR

class OCREngine:
    def __init__(self):
        self.ocr = PaddleOCR(use_angle_cls=True, lang='ch')
    
    def extract_text(self, screenshot: Screenshot) -> list[dict]:
        """ä»æˆªå›¾ä¸­æå–æ–‡æœ¬"""
        # è§£ç å›¾åƒ
        img_data = base64.b64decode(screenshot.base64_data)
        img = Image.open(BytesIO(img_data))
        
        # OCR è¯†åˆ«
        result = self.ocr.ocr(np.array(img), cls=True)
        
        texts = []
        for line in result[0]:
            box = line[0]  # [[x1,y1], [x2,y2], [x3,y3], [x4,y4]]
            text = line[1][0]  # è¯†åˆ«çš„æ–‡æœ¬
            confidence = line[1][1]  # ç½®ä¿¡åº¦
            
            # è®¡ç®—ä¸­å¿ƒç‚¹
            x_center = int(sum([p[0] for p in box]) / 4)
            y_center = int(sum([p[1] for p in box]) / 4)
            
            texts.append({
                "text": text,
                "confidence": confidence,
                "center": [x_center, y_center],
                "box": box
            })
        
        return texts
```

**é›†æˆåˆ° Agent**:
```python
# agent.py
def _execute_step(self, ...):
    screenshot = get_screenshot(device_id)
    
    # OCR è¯†åˆ«
    ocr_texts = self.ocr_engine.extract_text(screenshot)
    
    # æ·»åŠ åˆ°å±å¹•ä¿¡æ¯
    screen_info = MessageBuilder.build_screen_info(
        current_app=current_app,
        ocr_texts=ocr_texts[:20]  # å‰ 20 ä¸ªæ–‡æœ¬
    )
```

**å¢å¼ºæç¤ºè¯**:
```python
SYSTEM_PROMPT += """
å±å¹•ä¿¡æ¯ä¸­åŒ…å« OCR è¯†åˆ«çš„æ–‡æœ¬ï¼š
{
  "ocr_texts": [
    {"text": "æœç´¢", "center": [540, 100], "confidence": 0.98},
    {"text": "å‘å¸ƒ", "center": [960, 100], "confidence": 0.95}
  ]
}

å¦‚æœéœ€è¦ç‚¹å‡»æŸä¸ªæ–‡å­—ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨ OCR è¯†åˆ«çš„ä¸­å¿ƒåæ ‡ã€‚
"""
```

---

### 4. å®ç°ä»»åŠ¡ä¸­æ–­ä¸æ¢å¤

**ç›®æ ‡**: æ”¯æŒæš‚åœä»»åŠ¡ï¼Œç¨åç»§ç»­

**å®ç°**:

```python
# agent.py
import pickle

class PhoneAgent:
    def save_state(self, filepath: str = "agent_state.pkl"):
        """ä¿å­˜å½“å‰çŠ¶æ€"""
        state = {
            "context": self._context,
            "step_count": self._step_count,
            "config": self.agent_config
        }
        with open(filepath, "wb") as f:
            pickle.dump(state, f)
        print(f"âœ… State saved to {filepath}")
    
    def load_state(self, filepath: str = "agent_state.pkl"):
        """åŠ è½½çŠ¶æ€"""
        with open(filepath, "rb") as f:
            state = pickle.load(f)
        
        self._context = state["context"]
        self._step_count = state["step_count"]
        self.agent_config = state["config"]
        print(f"âœ… State loaded from {filepath}")
    
    def run_resumable(self, task: str):
        """å¯æ¢å¤çš„ä»»åŠ¡æ‰§è¡Œ"""
        try:
            return self.run(task)
        except KeyboardInterrupt:
            print("\nâš ï¸ Task interrupted")
            self.save_state()
            print("You can resume later by calling agent.resume()")
    
    def resume(self):
        """æ¢å¤ä»»åŠ¡"""
        if not os.path.exists("agent_state.pkl"):
            print("âŒ No saved state found")
            return
        
        self.load_state()
        print("ğŸ”„ Resuming task...")
        
        while self._step_count < self.agent_config.max_steps:
            result = self._execute_step(is_first=False)
            if result.finished:
                return result.message
        
        return "Max steps reached"
```

**ä½¿ç”¨**:
```python
agent = PhoneAgent()

# å¼€å§‹ä»»åŠ¡
agent.run_resumable("æ‰“å¼€æ·˜å®æœç´¢æ— çº¿è€³æœº")
# (æŒ‰ Ctrl+C ä¸­æ–­)

# ç¨åæ¢å¤
agent.resume()
```

---

## ğŸ† é«˜çº§æ”¹è¿›ï¼ˆ7-14å¤©ï¼‰

éœ€è¦æ·±å…¥ç†è§£å’Œè¾ƒå¼ºå¼€å‘èƒ½åŠ›ã€‚

### 1. å®ç°å¤šä»»åŠ¡å¹¶å‘æ‰§è¡Œ

**ç›®æ ‡**: åŒæ—¶æ§åˆ¶å¤šä¸ªè®¾å¤‡ï¼Œå¹¶è¡Œæ‰§è¡Œä»»åŠ¡

**æ¶æ„è®¾è®¡**:

```python
# agent.py
import threading
from concurrent.futures import ThreadPoolExecutor

class MultiDeviceAgent:
    """å¤šè®¾å¤‡å¹¶å‘ Agent"""
    
    def __init__(self, device_ids: list[str], model_config: ModelConfig):
        self.agents = {
            device_id: PhoneAgent(
                model_config=model_config,
                agent_config=AgentConfig(device_id=device_id)
            )
            for device_id in device_ids
        }
    
    def run_parallel(self, tasks: dict[str, str]) -> dict[str, str]:
        """
        å¹¶è¡Œæ‰§è¡Œå¤šä¸ªä»»åŠ¡
        
        Args:
            tasks: {device_id: task_description}
        
        Returns:
            {device_id: result}
        """
        results = {}
        
        with ThreadPoolExecutor(max_workers=len(tasks)) as executor:
            # æäº¤æ‰€æœ‰ä»»åŠ¡
            futures = {
                executor.submit(
                    self.agents[device_id].run, task
                ): device_id
                for device_id, task in tasks.items()
            }
            
            # æ”¶é›†ç»“æœ
            for future in futures:
                device_id = futures[future]
                try:
                    results[device_id] = future.result()
                except Exception as e:
                    results[device_id] = f"Error: {e}"
        
        return results
```

**ä½¿ç”¨**:
```python
# è¿æ¥å¤šä¸ªè®¾å¤‡
devices = ["emulator-5554", "192.168.1.100:5555"]

# åˆ›å»ºå¤šè®¾å¤‡ Agent
multi_agent = MultiDeviceAgent(
    device_ids=devices,
    model_config=ModelConfig()
)

# å¹¶è¡Œæ‰§è¡Œä»»åŠ¡
results = multi_agent.run_parallel({
    "emulator-5554": "æ‰“å¼€æŠ–éŸ³åˆ·è§†é¢‘",
    "192.168.1.100:5555": "æ‰“å¼€å°çº¢ä¹¦æœç´¢ç¾é£Ÿ"
})

for device_id, result in results.items():
    print(f"{device_id}: {result}")
```

**æ³¨æ„äº‹é¡¹**:
- ç¡®ä¿æ¨¡å‹ API æ”¯æŒå¹¶å‘
- æ¯ä¸ªè®¾å¤‡éœ€è¦ç‹¬ç«‹çš„ ADB è¿æ¥
- è€ƒè™‘èµ„æºé™åˆ¶ï¼ˆå†…å­˜ã€GPUï¼‰

---

### 2. å®ç°å­¦ä¹ ä¸ä¼˜åŒ–ç³»ç»Ÿ

**ç›®æ ‡**: ä»å†å²ä»»åŠ¡ä¸­å­¦ä¹ ï¼Œä¼˜åŒ–æœªæ¥æ‰§è¡Œ

**è®¾è®¡æ€è·¯**:

1. **è®°å½•æˆåŠŸæ¡ˆä¾‹**:
```python
# learning/experience_buffer.py
class ExperienceBuffer:
    """ç»éªŒå›æ”¾ç¼“å†²åŒº"""
    
    def __init__(self, max_size: int = 1000):
        self.buffer = []
        self.max_size = max_size
    
    def add(self, experience: dict):
        """æ·»åŠ ä¸€æ¬¡æˆåŠŸç»éªŒ"""
        self.buffer.append(experience)
        if len(self.buffer) > self.max_size:
            self.buffer.pop(0)
    
    def find_similar(self, task: str, top_k: int = 5) -> list[dict]:
        """æŸ¥æ‰¾ç›¸ä¼¼çš„å†å²ä»»åŠ¡"""
        # ç®€å•æ–¹æ³•: å…³é”®è¯åŒ¹é…
        similar = []
        task_keywords = set(task.split())
        
        for exp in self.buffer:
            exp_keywords = set(exp["task"].split())
            similarity = len(task_keywords & exp_keywords) / len(task_keywords | exp_keywords)
            
            if similarity > 0.3:
                similar.append((similarity, exp))
        
        # è¿”å›æœ€ç›¸ä¼¼çš„ top_k ä¸ª
        similar.sort(reverse=True, key=lambda x: x[0])
        return [exp for _, exp in similar[:top_k]]
```

2. **Few-Shot Prompting**:
```python
# agent.py
class PhoneAgent:
    def __init__(self, ...):
        # ... åŸæœ‰ä»£ç  ...
        self.experience_buffer = ExperienceBuffer()
    
    def _execute_step(self, user_prompt=None, is_first=False):
        if is_first:
            # æŸ¥æ‰¾ç›¸ä¼¼çš„å†å²ä»»åŠ¡
            similar_tasks = self.experience_buffer.find_similar(user_prompt)
            
            # æ„å»º Few-Shot ç¤ºä¾‹
            examples = "\n\n".join([
                f"ç¤ºä¾‹ä»»åŠ¡: {exp['task']}\næˆåŠŸæ­¥éª¤: {exp['steps']}"
                for exp in similar_tasks
            ])
            
            # å°†ç¤ºä¾‹æ·»åŠ åˆ° system prompt
            enhanced_prompt = self.agent_config.system_prompt + f"\n\nå‚è€ƒä»¥ä¸‹æˆåŠŸæ¡ˆä¾‹:\n{examples}"
            
            self._context.append(
                MessageBuilder.create_system_message(enhanced_prompt)
            )
        
        # ... åç»­æµç¨‹ ...
    
    def run(self, task: str) -> str:
        result = super().run(task)
        
        # ä»»åŠ¡æˆåŠŸ â†’ è®°å½•ç»éªŒ
        if result != "Max steps reached":
            self.experience_buffer.add({
                "task": task,
                "steps": self._get_step_summary(),
                "success": True
            })
        
        return result
```

3. **å¼ºåŒ–å­¦ä¹  (é«˜çº§)**:
- å°†ä»»åŠ¡å®Œæˆä½œä¸ºå¥–åŠ±ä¿¡å·
- ä½¿ç”¨ PPO/RLHF å¾®è°ƒæ¨¡å‹
- éœ€è¦å¤§é‡æ•°æ®å’Œç®—åŠ›

---

### 3. é›†æˆæ›´å¼ºçš„å¤šæ¨¡æ€æ¨¡å‹

**ç›®æ ‡**: æ”¯æŒå¤šç§ VLM æ¨¡å‹ï¼Œæé«˜ç†è§£èƒ½åŠ›

**å®ç°ç­–ç•¥**:

1. **æŠ½è±¡æ¨¡å‹æ¥å£**:
```python
# model/base.py
from abc import ABC, abstractmethod

class BaseVLMClient(ABC):
    @abstractmethod
    def request(self, messages: list[dict]) -> ModelResponse:
        pass

# model/openai_client.py
class OpenAIClient(BaseVLMClient):
    """OpenAI å…¼å®¹æ¥å£"""
    def request(self, messages):
        # åŸæœ‰å®ç°
        ...

# model/gemini_client.py
class GeminiClient(BaseVLMClient):
    """Google Gemini æ¥å£"""
    def request(self, messages):
        import google.generativeai as genai
        
        # è½¬æ¢æ¶ˆæ¯æ ¼å¼
        gemini_messages = self._convert_messages(messages)
        
        # è°ƒç”¨ Gemini API
        model = genai.GenerativeModel('gemini-pro-vision')
        response = model.generate_content(gemini_messages)
        
        # è§£æå“åº”
        return self._parse_response(response)

# model/gpt4v_client.py
class GPT4VClient(BaseVLMClient):
    """GPT-4V æ¥å£"""
    def request(self, messages):
        # ä½¿ç”¨ OpenAI GPT-4V
        ...
```

2. **é…ç½®åŒ–é€‰æ‹©**:
```python
# agent.py
class PhoneAgent:
    def __init__(self, model_config: ModelConfig, ...):
        # æ ¹æ®é…ç½®é€‰æ‹©æ¨¡å‹
        if model_config.model_type == "openai":
            self.model_client = OpenAIClient(model_config)
        elif model_config.model_type == "gemini":
            self.model_client = GeminiClient(model_config)
        elif model_config.model_type == "gpt4v":
            self.model_client = GPT4VClient(model_config)
        else:
            raise ValueError(f"Unknown model type: {model_config.model_type}")
```

3. **é›†æˆ Claude 3 Opus**:
```python
# model/claude_client.py
import anthropic

class ClaudeClient(BaseVLMClient):
    def __init__(self, config):
        self.client = anthropic.Anthropic(api_key=config.api_key)
        self.model = "claude-3-opus-20240229"
    
    def request(self, messages):
        # è½¬æ¢å›¾åƒæ ¼å¼
        claude_messages = self._convert_messages(messages)
        
        response = self.client.messages.create(
            model=self.model,
            max_tokens=3000,
            messages=claude_messages
        )
        
        content = response.content[0].text
        thinking, action = self._parse_response(content)
        
        return ModelResponse(thinking, action, content)
```

---

### 4. æ„å»ºè‡ªåŠ¨åŒ–æµ‹è¯•æ¡†æ¶

**ç›®æ ‡**: è‡ªåŠ¨æµ‹è¯• Agent åœ¨å„ç§åœºæ™¯ä¸‹çš„è¡¨ç°

**å®ç°**:

```python
# tests/test_agent.py
import pytest
from phone_agent import PhoneAgent
from phone_agent.model import ModelConfig

class TestPhoneAgent:
    @pytest.fixture
    def agent(self):
        """åˆ›å»ºæµ‹è¯• Agent"""
        return PhoneAgent(
            model_config=ModelConfig(base_url="http://localhost:8000/v1")
        )
    
    def test_launch_app(self, agent):
        """æµ‹è¯•å¯åŠ¨åº”ç”¨"""
        result = agent.run("æ‰“å¼€å¾®ä¿¡")
        assert "å®Œæˆ" in result or "å¾®ä¿¡" in result
    
    def test_search_task(self, agent):
        """æµ‹è¯•æœç´¢ä»»åŠ¡"""
        result = agent.run("æ‰“å¼€æ·˜å®æœç´¢æ— çº¿è€³æœº")
        assert agent.step_count > 0
        assert agent.step_count < 20  # åˆç†çš„æ­¥æ•°
    
    def test_error_recovery(self, agent):
        """æµ‹è¯•é”™è¯¯æ¢å¤"""
        # æ¨¡æ‹Ÿé”™è¯¯åœºæ™¯
        result = agent.run("æ‰“å¼€ä¸å­˜åœ¨çš„åº”ç”¨XYZ")
        assert "error" in result.lower() or "å¤±è´¥" in result
    
    @pytest.mark.parametrize("task,expected_app", [
        ("æ‰“å¼€å¾®ä¿¡", "å¾®ä¿¡"),
        ("æ‰“å¼€æŠ–éŸ³", "æŠ–éŸ³"),
        ("æ‰“å¼€æ·˜å®", "æ·˜å®"),
    ])
    def test_multiple_apps(self, agent, task, expected_app):
        """å‚æ•°åŒ–æµ‹è¯•å¤šä¸ªåº”ç”¨"""
        result = agent.run(task)
        assert expected_app in result or "å®Œæˆ" in result

# tests/test_integration.py
class TestIntegration:
    """é›†æˆæµ‹è¯•"""
    
    def test_full_workflow(self):
        """å®Œæ•´å·¥ä½œæµæµ‹è¯•"""
        agent = PhoneAgent()
        
        # 1. å¯åŠ¨åº”ç”¨
        result = agent.run("æ‰“å¼€ç¾å›¢")
        assert "å®Œæˆ" in result
        
        # 2. æœç´¢
        agent.reset()
        result = agent.run("æ‰“å¼€ç¾å›¢æœç´¢ç«é”…åº—")
        assert agent.step_count > 2
        
        # 3. æ£€æŸ¥å†å²
        assert len(agent.context) > 0
```

**è¿è¡Œæµ‹è¯•**:
```bash
pytest tests/ -v --tb=short
```

**CI/CD é›†æˆ**:
```yaml
# .github/workflows/test.yml
name: Test Agent

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: 3.10
      
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install pytest
      
      - name: Run tests
        run: pytest tests/
```

---

## ğŸ”’ å®‰å…¨æ€§æ”¹è¿›

### æ›¿æ¢ `eval()` ä¸ºå®‰å…¨è§£æ

**å½“å‰é—®é¢˜**:
```python
# actions/handler.py - ä¸å®‰å…¨!
action = eval(response)  # å¯èƒ½æ‰§è¡Œæ¶æ„ä»£ç 
```

**å®‰å…¨æ–¹æ¡ˆ**:

```python
# actions/handler.py
import ast

def parse_action_safe(response: str) -> dict:
    """å®‰å…¨çš„åŠ¨ä½œè§£æ"""
    try:
        # ä½¿ç”¨ AST è€Œé eval
        tree = ast.parse(response, mode='eval')
        
        # éªŒè¯åªåŒ…å«å‡½æ•°è°ƒç”¨
        if not isinstance(tree.body, ast.Call):
            raise ValueError("Invalid action format")
        
        func_name = tree.body.func.id
        
        # åªå…è®¸ do å’Œ finish
        if func_name not in ["do", "finish"]:
            raise ValueError(f"Unknown function: {func_name}")
        
        # æå–å‚æ•°
        kwargs = {}
        for keyword in tree.body.keywords:
            arg_name = keyword.arg
            arg_value = ast.literal_eval(keyword.value)
            kwargs[arg_name] = arg_value
        
        # æ„å»ºåŠ¨ä½œå­—å…¸
        kwargs["_metadata"] = func_name
        return kwargs
    
    except Exception as e:
        raise ValueError(f"Failed to parse action: {e}")
```

**æµ‹è¯•**:
```python
# æ­£å¸¸è¾“å…¥
>>> parse_action_safe('do(action="Tap", element=[500, 200])')
{'action': 'Tap', 'element': [500, 200], '_metadata': 'do'}

# æ¶æ„è¾“å…¥
>>> parse_action_safe('__import__("os").system("rm -rf /")')
ValueError: Invalid action format
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–

### 1. å›¾åƒå‹ç¼©

**ç›®æ ‡**: å‡å°‘å›¾åƒå¤§å°ï¼ŒèŠ‚çœ token

```python
# adb/screenshot.py
def get_screenshot(device_id=None, max_size=(720, 1280)):
    """è·å–å‹ç¼©åçš„æˆªå›¾"""
    # ... åŸæœ‰æˆªå›¾é€»è¾‘ ...
    
    img = Image.open(temp_path)
    
    # å¦‚æœå›¾åƒè¿‡å¤§ï¼Œç¼©æ”¾
    if img.width > max_size[0] or img.height > max_size[1]:
        img.thumbnail(max_size, Image.Resampling.LANCZOS)
    
    # å‹ç¼©è´¨é‡
    buffered = BytesIO()
    img.save(buffered, format="JPEG", quality=80)
    base64_data = base64.b64encode(buffered.getvalue()).decode("utf-8")
    
    return Screenshot(base64_data, img.width, img.height)
```

**æ•ˆæœ**:
- åŸå§‹ 1080x2400 PNG: ~2MB â†’ ~300KB
- Token èŠ‚çœ: ~60%

---

### 2. ç¼“å­˜æ¨¡å‹å“åº”

**ç›®æ ‡**: ç›¸åŒå±å¹•ä¸é‡å¤æ¨ç†

```python
# model/client.py
import hashlib

class ModelClient:
    def __init__(self, config):
        # ... åŸæœ‰ä»£ç  ...
        self.cache = {}  # {state_hash: response}
    
    def request(self, messages):
        # è®¡ç®—çŠ¶æ€å“ˆå¸Œ
        state_hash = self._hash_messages(messages)
        
        # æ£€æŸ¥ç¼“å­˜
        if state_hash in self.cache:
            print("âœ… Cache hit!")
            return self.cache[state_hash]
        
        # è°ƒç”¨æ¨¡å‹
        response = self._request_impl(messages)
        
        # ç¼“å­˜ç»“æœ
        self.cache[state_hash] = response
        
        return response
    
    def _hash_messages(self, messages):
        """è®¡ç®—æ¶ˆæ¯çš„å“ˆå¸Œå€¼"""
        # åªå“ˆå¸Œæœ€æ–°çš„å›¾åƒ + æ–‡æœ¬
        last_message = messages[-1]
        content_str = json.dumps(last_message, sort_keys=True)
        return hashlib.md5(content_str.encode()).hexdigest()
```

---

## ğŸ“ å®è·µå»ºè®®

### é€‰æ‹©æ”¹è¿›æ–¹å‘çš„åŸåˆ™

1. **ä»å°å¤„ç€æ‰‹**: å…ˆå®Œæˆåˆçº§æ”¹è¿›ï¼Œç§¯ç´¯ç»éªŒ
2. **è§£å†³å®é™…é—®é¢˜**: é€‰æ‹©ä½ åœ¨ä½¿ç”¨ä¸­é‡åˆ°çš„é—®é¢˜
3. **å¾ªåºæ¸è¿›**: ä¸è¦ä¸€æ¬¡æ”¹å¤ªå¤šï¼Œé€æ­¥è¿­ä»£
4. **æµ‹è¯•é©±åŠ¨**: æ¯æ¬¡æ”¹è¿›éƒ½è¦æµ‹è¯•æ•ˆæœ

### å­¦ä¹ è·¯å¾„å»ºè®®

**Week 1**: åˆçº§æ”¹è¿› (æ·»åŠ åŠ¨ä½œã€åº”ç”¨)  
**Week 2**: ä¸­çº§æ”¹è¿› (UIAutomator é›†æˆ)  
**Week 3**: é«˜çº§æ”¹è¿› (å¹¶å‘æ‰§è¡Œ)  
**Week 4**: æ€§èƒ½ä¼˜åŒ– + å®‰å…¨åŠ å›º  

---

## ğŸ“ æ€»ç»“

### æ”¹è¿›ä¼˜å…ˆçº§

| æ”¹è¿› | ä»·å€¼ | éš¾åº¦ | ä¼˜å…ˆçº§ |
|------|------|------|--------|
| UIAutomator é›†æˆ | â­â­â­ | ä¸­ | é«˜ |
| OCR æ–‡æœ¬è¯†åˆ« | â­â­â­ | ä¸­ | é«˜ |
| æ™ºèƒ½é‡è¯• | â­â­ | ä½ | é«˜ |
| å®‰å…¨è§£æ (æ›¿æ¢ eval) | â­â­â­ | ä½ | é«˜ |
| ä»»åŠ¡å†å² | â­â­ | ä½ | ä¸­ |
| å¹¶å‘æ‰§è¡Œ | â­â­ | é«˜ | ä¸­ |
| å­¦ä¹ ç³»ç»Ÿ | â­â­â­ | é«˜ | ä½ |
| æ¨¡å‹é›†æˆ | â­â­ | ä¸­ | ä½ |

### é¢„æœŸæ•ˆæœ

å®Œæˆè¿™äº›æ”¹è¿›åï¼Œç³»ç»Ÿå°†ï¼š
- âœ… ç‚¹å‡»å‡†ç¡®ç‡æå‡ 30%+
- âœ… ä»»åŠ¡æˆåŠŸç‡æå‡ 20%+
- âœ… å“åº”é€Ÿåº¦æå‡ 50%+
- âœ… å®‰å…¨æ€§æ˜¾è‘—å¢å¼º
- âœ… å¯ç»´æŠ¤æ€§å¤§å¹…æ”¹å–„

---

**é€‰æ‹©ä¸€ä¸ªæ–¹å‘ï¼Œå¼€å§‹åŠ¨æ‰‹å®è·µå§ï¼ğŸš€**



# Open-AutoGLM 精彩设计解析

本文档深入分析项目中值得学习的巧妙设计和最佳实践。

---

## 🎯 设计亮点 1: 归一化坐标系统

### 问题背景

不同 Android 设备的屏幕分辨率差异巨大：
- 低端设备: 720x1280
- 中端设备: 1080x2400  
- 高端设备: 1440x3200

如果直接使用绝对像素坐标，模型需要：
- 为每种分辨率单独训练
- 在推理时知道设备分辨率
- 输出结果无法跨设备使用

### 解决方案: 0-1000 归一化坐标

**设计思想**: 将所有屏幕统一映射到 1000x1000 的虚拟空间

```
虚拟坐标系 (0-1000)          实际屏幕 (1080x2400)
┌─────────────────┐          ┌──────────────────────┐
│ (0,0)  (1000,0) │          │ (0,0)      (1080,0)  │
│                 │   转换    │                      │
│    (500,500)    │  ════>   │      (540,1200)      │
│                 │          │                      │
│(0,1000)(1000,   │          │ (0,2400)  (1080,2400)│
└─────────────────┘          └──────────────────────┘
```

**转换公式**:
```python
x_pixel = int(x_relative / 1000 * screen_width)
y_pixel = int(y_relative / 1000 * screen_height)
```

### 设计优势

1. **设备无关性**: 
   - 模型输出 `[500, 200]` 在任何设备上都表示"水平中央、靠上"
   - 无需关心具体分辨率

2. **训练效率**: 
   - 所有训练数据使用统一坐标
   - 模型泛化能力强

3. **人类可读**: 
   - `[500, 500]` 一眼就能看出是屏幕中心
   - `[0, 0]` 显然是左上角

4. **数值稳定性**: 
   - 坐标范围固定 (0-1000)
   - 避免大数值对模型训练的影响

### 对比其他方案

| 方案 | 优点 | 缺点 |
|------|------|------|
| 绝对像素 | 精确 | 需要知道分辨率，无法泛化 |
| 0-1 归一化 | 标准化 | 精度不足，难以表达精细位置 |
| 0-1000 归一化 ⭐ | 精度 + 可读性 + 泛化 | 需要转换步骤 |
| 相对百分比 | 直观 | 小数处理麻烦 |

### 实现细节

```python
# actions/handler.py
def _convert_relative_to_absolute(
    self, element: list[int], 
    screen_width: int, screen_height: int
) -> tuple[int, int]:
    """
    将相对坐标 (0-1000) 转换为绝对像素坐标
    
    Args:
        element: [x, y] 相对坐标 (0-1000)
        screen_width: 屏幕宽度（像素）
        screen_height: 屏幕高度（像素）
    
    Returns:
        (x_pixel, y_pixel) 绝对坐标
    """
    x = int(element[0] / 1000 * screen_width)
    y = int(element[1] / 1000 * screen_height)
    return x, y
```

**学习价值**: 这个设计体现了"抽象层"的思想，通过引入中间表示解决跨平台问题。

---

## 🧠 设计亮点 2: Think-Answer 模式

### 问题背景

早期 AI 系统直接输出动作：
```
Input: 屏幕截图
Output: do(action="Tap", element=[500, 200])
```

问题：
- 决策过程不可见，难以调试
- 出错时无法分析原因
- 用户不信任 AI 的决策

### 解决方案: 思维链 (Chain-of-Thought)

**强制 AI 先思考，再输出动作**：

```xml
<think>
当前在系统桌面，需要先启动小红书应用。
根据任务要求搜索美食攻略，首先需要进入应用。
</think>

<answer>
do(action="Launch", app="小红书")
</answer>
```

### 设计优势

1. **可解释性**: 
   - 用户可以看到 AI 的推理过程
   - 增强信任感

2. **调试友好**: 
   - 出错时可以判断是"理解错误"还是"执行错误"
   - 例: 思考正确但点击位置不对 → 坐标问题

3. **提高准确性**: 
   - 思维链本身提升了 AI 的推理能力
   - 复杂任务的成功率更高 (CoT 效应)

4. **日志价值**: 
   - 思考内容可以用于后续分析和改进
   - 构建失败案例数据集

### 实现方式

**Prompt 约束**:
```python
SYSTEM_PROMPT = """
你必须严格按照要求输出以下格式：
<think>{think}</think>
<answer>{action}</answer>

其中：
- {think} 是对你为什么选择这个操作的简短推理说明。
- {action} 是本次执行的具体操作指令。
"""
```

**解析代码**:
```python
def _parse_response(self, content: str) -> tuple[str, str]:
    if "<answer>" not in content:
        return "", content  # 容错: 没有格式时全部当作动作
    
    parts = content.split("<answer>", 1)
    thinking = parts[0].replace("<think>", "").replace("</think>", "").strip()
    action = parts[1].replace("</answer>", "").strip()
    
    return thinking, action
```

### 真实案例

**任务**: "打开美团搜索附近的火锅店"

```
Step 1:
💭 Think: 当前在系统桌面，需要先启动美团应用
🎯 Action: do(action="Launch", app="美团")

Step 2:
💭 Think: 美团已打开，页面显示首页。需要点击顶部搜索框进入搜索页面
🎯 Action: do(action="Tap", element=[500, 100])

Step 3:
💭 Think: 搜索框已激活，现在输入"火锅店"
🎯 Action: do(action="Type", text="火锅店")

Step 4:
💭 Think: 已输入搜索词，点击搜索按钮
🎯 Action: do(action="Tap", element=[950, 100])

Step 5:
💭 Think: 搜索结果已显示，任务完成
🎯 Action: finish(message="已成功搜索附近的火锅店")
```

**学习价值**: Think-Answer 模式是多模态 Agent 的标准范式，值得在其他项目中应用。

---

## 🔄 设计亮点 3: 上下文管理策略

### 问题背景

多模态对话历史会快速消耗 token：
- 每张图像: ~1000-2000 tokens
- 10 步执行: 10 张图像 = 10,000-20,000 tokens
- 加上文本: 总共可能超过 30,000 tokens

### 解决方案: 渐进式图像清理

**核心思想**: 只保留最新的一张图像

```python
# agent.py - _execute_step()
def _execute_step(self, ...):
    # ... 构建消息，添加新图像 ...
    
    # 删除上一条消息中的图像
    self._context[-1] = MessageBuilder.remove_images_from_message(
        self._context[-1]
    )
    
    # ... 执行动作 ...
```

### 上下文演变过程

**Step 1**:
```
[System] 系统提示词
[User] 任务 + 🖼️ 图像1
```

**Step 2 (添加新消息前)**:
```
[System] 系统提示词
[User] 任务 + 🖼️ 图像1
[Assistant] <think>...</think><answer>do(...)</answer>
[User] 屏幕信息 + 🖼️ 图像2  ← 新增
```

**Step 2 (清理后)**:
```
[System] 系统提示词
[User] 任务 + ❌ (图像已删除)
[Assistant] <think>...</think><answer>do(...)</answer>
[User] 屏幕信息 + 🖼️ 图像2  ← 只保留最新
```

### 设计优势

1. **Token 节省**: 
   - 无图像清理: O(n) 增长
   - 有图像清理: O(1) 稳定

2. **保留推理历史**: 
   - 所有文本内容完整保留
   - AI 仍能知道之前做了什么

3. **性能优化**: 
   - 推理速度更快
   - 成本更低

### 实现细节

```python
# model/client.py
@staticmethod
def remove_images_from_message(message: dict) -> dict:
    """删除消息中的图像内容，只保留文本"""
    if isinstance(message.get("content"), list):
        message["content"] = [
            item for item in message["content"] 
            if item.get("type") == "text"  # 只保留文本
        ]
    return message
```

### 未来改进方向

可以考虑更激进的策略：
- **关键帧保留**: 保留任务开始、完成等关键时刻的图像
- **图像压缩**: 降低分辨率后保留
- **摘要机制**: 用文本描述替代图像 (需要额外的 VQA 模型)

**学习价值**: 这是多模态系统中常见的优化策略，体现了工程与效果的平衡。

---

## 📝 设计亮点 4: 规则驱动的提示词工程

### 问题背景

纯粹的端到端模型容易出现：
- 进入错误页面后不知道返回
- 陷入循环操作 (一直滑动)
- 忽略页面加载时间
- 不检查上一步操作是否生效

### 解决方案: 18 条行为规则

项目通过精心设计的规则引导 AI 行为：

#### 规则类型分析

**1. 前置检查规则** (防止错误):
```
规则1: 在执行任何操作前，先检查当前app是否是目标app，如果不是，先执行 Launch。
```

**2. 错误恢复规则** (容错):
```
规则2: 如果进入到了无关页面，先执行 Back。
规则3: 如果页面未加载出内容，最多连续 Wait 三次，否则执行 Back重新进入。
```

**3. 防止死循环规则** (健壮性):
```
规则13: 执行任务过程中如果有多个可选择的项目栏，请逐个查找每个项目栏，
       直到完成任务，一定不要在同一项目栏多次查找，从而陷入死循环。
```

**4. 操作验证规则** (质量):
```
规则14: 在执行下一步操作前请一定要检查上一步的操作是否生效，
       如果点击没生效，可能因为app反应较慢，请先稍微等待一下。
```

**5. 任务完成检查规则** (准确性):
```
规则18: 在结束任务前请一定要仔细检查任务是否完整准确的完成，
       如果出现错选、漏选、多选的情况，请返回之前的步骤进行纠正。
```

### 规则驱动 vs 端到端

| 对比维度 | 纯端到端 | 规则驱动 (本项目) |
|----------|----------|-------------------|
| 可控性 | 低 | 高 |
| 可解释性 | 低 | 高 |
| 调试难度 | 高 | 低 |
| 泛化能力 | 高 | 中 |
| 维护成本 | 低 | 中 |

**本项目选择**: 规则驱动 + 模型能力 = 混合方案

### 规则设计技巧

1. **具体化**: 
   ```
   ❌ 不好: "注意页面加载"
   ✅ 好: "如果页面未加载出内容，最多连续 Wait 三次"
   ```

2. **提供策略**: 
   ```
   ❌ 不好: "不要陷入循环"
   ✅ 好: "请逐个查找每个项目栏，不要在同一项目栏多次查找"
   ```

3. **容错指导**: 
   ```
   ❌ 不好: "点击要准确"
   ✅ 好: "如果点击没生效，请调整一下点击位置重试"
   ```

### 真实效果

**无规则时**:
```
Step 5: Swipe (向下滑动)
Step 6: Swipe (向下滑动)
Step 7: Swipe (向下滑动)
...
Step 20: Swipe (向下滑动)  ← 死循环
```

**有规则 13 后**:
```
Step 5: Swipe (向下滑动)
Step 6: Swipe (向下滑动)
Step 7: Think: 在"推荐"栏目中没找到，切换到"关注"栏目
Step 8: Tap (点击"关注"标签)
```

**学习价值**: 提示词工程不是简单的文本编写，而是系统设计。规则应该具体、可执行、有策略。

---

## 🛡️ 设计亮点 5: 多层容错机制

### 容错设计层次

```
第1层: 模型 API 容错
  ↓
第2层: 响应解析容错
  ↓
第3层: 动作执行容错
  ↓
第4层: 设备通信容错
  ↓
第5层: 敏感场景检测
```

### 1. 模型 API 容错

```python
# agent.py
try:
    response = self.model_client.request(self._context)
except Exception as e:
    if self.agent_config.verbose:
        traceback.print_exc()
    return StepResult(
        success=False,
        finished=True,
        action=None,
        thinking="",
        message=f"Model error: {e}"
    )
```

**容错策略**: 捕获异常 → 返回错误结果 → 结束任务

---

### 2. 响应解析容错

```python
# agent.py
try:
    action = parse_action(response.action)
except ValueError:
    if self.agent_config.verbose:
        traceback.print_exc()
    # 解析失败 → 当作 finish 处理
    action = finish(message=response.action)
```

**容错策略**: 解析失败 → 将内容当作完成消息 → 优雅结束

---

### 3. 动作执行容错

```python
# agent.py
try:
    result = self.action_handler.execute(
        action, screenshot.width, screenshot.height
    )
except Exception as e:
    if self.agent_config.verbose:
        traceback.print_exc()
    # 执行失败 → 强制结束并报告错误
    result = self.action_handler.execute(
        finish(message=str(e)), 
        screenshot.width, screenshot.height
    )
```

**容错策略**: 执行异常 → 转换为 finish 动作 → 记录错误

---

### 4. 敏感页面检测

```python
# adb/screenshot.py
result = subprocess.run(["adb", "shell", "screencap", ...])
output = result.stdout + result.stderr

if "Status: -1" in output or "Failed" in output:
    # 截图失败 (敏感页面) → 返回黑屏
    return _create_fallback_screenshot(is_sensitive=True)
```

**容错策略**: 截图失败 → 黑屏 + 标记 → Agent 触发 Take_over

---

### 5. 默认容错响应

```python
# actions/handler.py
def _parse_response(self, content: str):
    if "<answer>" not in content:
        # 没有标准格式 → 全部当作动作
        return "", content
    ...
```

**容错策略**: 格式不对 → 尽力解析 → 返回可用内容

---

### 容错设计原则

1. **防御性编程**: 假设任何外部调用都可能失败
2. **优雅降级**: 不能正常工作时，提供备选方案
3. **信息保留**: 错误信息传递给上层，便于调试
4. **用户友好**: 敏感操作请求人工介入，而非直接失败

**学习价值**: 生产级系统必须考虑容错，这些设计可以直接借鉴到其他项目。

---

## 🔌 设计亮点 6: ADB Keyboard 方案

### 问题背景

ADB 原生输入命令的局限：
```bash
# 只能输入英文和数字
adb shell input text "Hello"

# 无法输入中文
adb shell input text "你好"  # ❌ 失败

# 特殊字符需要转义
adb shell input text "hello@world.com"  # ❌ @ 符号有问题
```

### 解决方案: ADB Keyboard

**原理**: 
1. 安装一个特殊的 Android 输入法 (ADB Keyboard)
2. 通过广播 (Broadcast) 发送文本
3. 输入法接收广播，将文本插入到输入框

**流程**:
```
1. 检测当前输入法
2. 切换到 ADB Keyboard
3. 发送广播: am broadcast -a ADB_INPUT_TEXT --es msg "你好"
4. ADB Keyboard 接收广播，插入文本
5. 恢复原输入法
```

### 实现代码

```python
# adb/input.py
def type_text(text: str, device_id: str | None = None):
    """通过 ADB Keyboard 输入文本"""
    adb_prefix = _get_adb_prefix(device_id)
    
    # 发送广播
    subprocess.run(
        adb_prefix + [
            "shell", "am", "broadcast",
            "-a", "ADB_INPUT_TEXT",
            "--es", "msg", text
        ],
        capture_output=True
    )

def detect_and_set_adb_keyboard(device_id: str | None = None) -> str:
    """切换到 ADB Keyboard，返回原输入法"""
    # 1. 获取当前输入法
    result = subprocess.run(
        adb_prefix + ["shell", "settings", "get", "secure", "default_input_method"],
        capture_output=True, text=True
    )
    original_ime = result.stdout.strip()
    
    # 2. 切换到 ADB Keyboard
    subprocess.run(
        adb_prefix + [
            "shell", "ime", "set", 
            "com.android.adbkeyboard/.AdbIME"
        ],
        capture_output=True
    )
    
    return original_ime

def restore_keyboard(original_ime: str, device_id: str | None = None):
    """恢复原输入法"""
    subprocess.run(
        adb_prefix + ["shell", "ime", "set", original_ime],
        capture_output=True
    )
```

### 设计优势

1. **支持任意字符**: 中文、emoji、特殊符号
2. **无需转义**: 直接发送原始文本
3. **用户体验**: 自动切换和恢复输入法
4. **可靠性**: 成熟的第三方工具

### 输入流程示例

```python
# actions/handler.py - _handle_type()
def _handle_type(self, action: dict, width: int, height: int):
    text = action.get("text", "")
    
    # 1. 切换到 ADB Keyboard
    original_ime = detect_and_set_adb_keyboard(self.device_id)
    time.sleep(1.0)
    
    # 2. 清空输入框
    clear_text(self.device_id)
    time.sleep(1.0)
    
    # 3. 输入文本
    type_text(text, self.device_id)
    time.sleep(1.0)
    
    # 4. 恢复原输入法
    restore_keyboard(original_ime, self.device_id)
    time.sleep(1.0)
    
    return ActionResult(True, False)
```

**学习价值**: 遇到系统限制时，寻找第三方工具或 workaround 是工程实践的重要技能。

---

## 🎨 设计亮点 7: 回调机制

### 问题背景

某些操作需要外部介入：
- 敏感操作确认 (支付、删除)
- 人工接管 (登录、验证码)

硬编码交互方式不够灵活。

### 解决方案: 回调函数

```python
# agent.py
class PhoneAgent:
    def __init__(
        self,
        confirmation_callback: Callable[[str], bool] | None = None,
        takeover_callback: Callable[[str], None] | None = None,
    ):
        self.action_handler = ActionHandler(
            confirmation_callback=confirmation_callback,
            takeover_callback=takeover_callback,
        )
```

### 使用示例

**默认回调 (控制台)**:
```python
# actions/handler.py
@staticmethod
def _default_confirmation(message: str) -> bool:
    """默认确认回调"""
    response = input(f"Sensitive operation: {message}\nConfirm? (Y/N): ")
    return response.upper() == "Y"

@staticmethod
def _default_takeover(message: str) -> None:
    """默认接管回调"""
    input(f"{message}\nPress Enter after completing manual operation...")
```

**自定义回调 (GUI)**:
```python
def my_confirmation(message: str) -> bool:
    """GUI 确认对话框"""
    return messagebox.askyesno("确认操作", message)

def my_takeover(message: str) -> None:
    """GUI 提示"""
    messagebox.showinfo("需要人工操作", message)
    # 阻塞直到用户点击确认

agent = PhoneAgent(
    confirmation_callback=my_confirmation,
    takeover_callback=my_takeover
)
```

**自定义回调 (Web API)**:
```python
def api_confirmation(message: str) -> bool:
    """通过 API 请求用户确认"""
    response = requests.post("https://api.example.com/confirm", json={
        "message": message
    })
    return response.json()["confirmed"]

def api_takeover(message: str) -> None:
    """通过 API 通知用户"""
    requests.post("https://api.example.com/takeover", json={
        "message": message
    })
    # 等待用户完成操作的回调
    wait_for_user_completion()
```

### 设计优势

1. **解耦**: Agent 不关心具体如何与用户交互
2. **灵活**: 支持控制台、GUI、Web 等多种方式
3. **可测试**: 测试时可以注入自动确认的回调

**学习价值**: 回调机制是实现可扩展性的经典模式。

---

## 📊 设计总结

### 核心设计模式

| 设计模式 | 应用场景 | 文件位置 |
|----------|----------|----------|
| **策略模式** | 动作处理器 | `actions/handler.py` |
| **模板方法** | Agent 主循环 | `agent.py` |
| **依赖注入** | 配置传递 | `agent.py`, `model/client.py` |
| **适配器模式** | OpenAI API 封装 | `model/client.py` |
| **观察者模式** | 回调机制 | `actions/handler.py` |

### 最值得学习的 5 个设计

1. ⭐⭐⭐ **归一化坐标系统**: 跨设备泛化的典范
2. ⭐⭐⭐ **Think-Answer 模式**: 可解释 AI 的标准做法
3. ⭐⭐⭐ **上下文管理策略**: 多模态系统的必备优化
4. ⭐⭐ **规则驱动提示词**: Prompt Engineering 的实战案例
5. ⭐⭐ **多层容错机制**: 生产级系统的健壮性保证

### 可直接迁移的经验

- ✅ 归一化坐标 → 其他视觉 Agent 系统
- ✅ Think-Answer → 任何需要解释的 AI 系统
- ✅ 上下文清理 → 所有多模态对话系统
- ✅ 规则驱动 → 复杂任务的 AI Agent
- ✅ 回调机制 → 需要人机协同的系统

---

**学习这些设计，你将获得构建生产级 AI 系统的能力！🚀**


